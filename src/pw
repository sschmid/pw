#!/usr/bin/env bash
set -euo pipefail

PW_HOME="${BASH_SOURCE[0]}"
while [[ -L "${PW_HOME}" ]]; do
  PW_HOME="$(readlink "${PW_HOME}")"
done
PW_HOME="$(cd "$(dirname "${PW_HOME}")/.." && pwd)"

: "${PW_KEYCHAIN:="login.keychain"}"
PW_NAME=""
PW_ACCOUNT=""
declare -ig PW_FZF=0

pw::help() {
  cat << EOF
██████╗ ██╗    ██╗
██╔══██╗██║    ██║
██████╔╝██║ █╗ ██║
██╔═══╝ ██║███╗██║
██║     ╚███╔███╔╝
╚═╝      ╚══╝╚══╝  $(cat "${PW_HOME}/version.txt")

usage: pw [-p] [-a | -k <keychain>] [<commands>]

options:
  -p              print password instead of copying
  -a              search in all user keychains
  -k <keychain>   search in given keychain

commands:
  [-p] no command             copy (or print) password using fuzzy finder
  [-p] <name> [<account>]     copy (or print) password
  init                        create keychain (default: login.keychain)
  open                        open keychain in Keychain Access
  lock                        lock keychain
  unlock                      unlock keychain
  add <name> [<account>]      add entry (leave password empty to generate one)
  edit [<name>] [<account>]   edit entry (leave password empty to generate one)
  rm [<name>] [<account>]     remove entry
  ls                          list all entries
  update                      update pw
  help                        show this
EOF
}

pw::init() { security create-keychain -P "${PW_KEYCHAIN}"; }
pw::open() { open -a "Keychain Access" ~/Library/Keychains/"${PW_KEYCHAIN}-db"; }
pw::lock() { security lock-keychain "${PW_KEYCHAIN}"; }
pw::unlock() { security unlock-keychain "${PW_KEYCHAIN}"; }

pw::add() {
  local -i edit=$1; shift
  ((edit)) || unset edit
  PW_NAME="$1" PW_ACCOUNT="${2:-}"
  local password retype
  read -rsp "Enter password for ${PW_NAME}: " password; echo
  if [[ -n "${password}" ]]; then
    read -rsp "Retype password for ${PW_NAME}: " retype; echo
    if [[ "${retype}" != "${password}" ]]; then
      echo "Error: the entered passwords do not match."
      exit 1
    fi
  else
    # shellcheck disable=SC2005
    password="$(echo "$(LC_CTYPE=C tr -dc '[:alnum:][:punct:]' < /dev/urandom | head -c 32)"))"
  fi
  security add-generic-password ${edit:+-U} -a "${PW_ACCOUNT}" -s "${PW_NAME}" -w "${password}" "${PW_KEYCHAIN}"
}

pw::edit() {
  pw::select edit "$@"
  pw::add 1 "${PW_NAME}" "${PW_ACCOUNT}"
}

pw::get() {
  local -i print=$1; shift
  ((PW_ALL)) || local keychain="${PW_KEYCHAIN}"
  if ((print))
  then pw::select print "$@"
  else pw::select copy "$@"
  fi
  local password
  password="$(security find-generic-password ${PW_ACCOUNT:+-a ${PW_ACCOUNT}} -s "${PW_NAME}" -w ${keychain:+${keychain}})"
  if ((print))
  then echo "${password}"
  else echo -n "${password}" | pbcopy
  fi
}

pw::rm() {
  local -i remove=1
  pw::select remove "$@"
  if ((PW_FZF)); then
    read -rp "Do you really want to remove ${PW_NAME:+"'${PW_NAME}' "}${PW_ACCOUNT:+"'${PW_ACCOUNT}' "}from ${PW_KEYCHAIN}? (y / n): "
    [[ "${REPLY}" == "y" ]] || remove=0
  fi
  ((!remove)) || security delete-generic-password -a "${PW_ACCOUNT}" -s "${PW_NAME}" "${PW_KEYCHAIN}" > /dev/null
}

pw::list() {
  local dump
  local -a names accounts keychains name account
  if ((PW_ALL))
  then mapfile -t keychains < <(security list-keychains -d user | tr -d \")
  else keychains=("${PW_KEYCHAIN}")
  fi
  for keychain in "${keychains[@]}"; do
    keychain="${keychain##*/}"
    dump="$(security dump-keychain "${keychain}")"
    mapfile -t names < <(echo "${dump}" | grep "svce" | awk -F= '{print $2}' | tr -d \")
    mapfile -t accounts < <(echo "${dump}" | grep "acct" | awk -F= '{print $2}' | tr -d \")
    for ((i = 0; i < ${#names[@]}; i++)); do
      name="${names[i]}"
      account="${accounts[i]}"
      [[ "${name}" == "<NULL>" ]] && name=""
      [[ "${account}" == "<NULL>" ]] && account=""
      printf "%-16s\t%-16s\t%s\n" "${name}" "${account}" "${keychain}"
    done | sort
  done
}

pw::update() {
  pushd "${PW_HOME}" > /dev/null || exit 1
    git pull origin main
  popd > /dev/null || exit 1
}

pw::select() {
  local fzf_prompt="$1"; shift
  if (($#))
  then PW_NAME="$1" PW_ACCOUNT="${2:-}" PW_FZF=0
  else pw::fzf "${fzf_prompt}" && PW_FZF=1
  fi
}

pw::fzf() {
  local fzf_prompt="$1" name account keychain
  while IFS=$'\t' read -r name account keychain; do
    PW_NAME="${name%% *}" PW_ACCOUNT="${account%% *}" PW_KEYCHAIN="${keychain}"
  done < <(pw::list | fzf --prompt="${fzf_prompt}> " --layout=reverse --info=hidden)
  if [[ -z "${PW_NAME}" && -z "${PW_ACCOUNT}" ]]; then exit 1; fi
}

declare -ig PW_ALL=0

main() {
  local -i print=0
  while (($#)); do case "$1" in
    -p) shift; print=1 ;;
    -a) shift; PW_ALL=1 ;;
    -k)
      PW_KEYCHAIN="$2"; shift 2;
      [[ "${PW_KEYCHAIN}" == *.keychain ]] || PW_KEYCHAIN+=.keychain ;;
    --) shift; break ;; *) break ;;
  esac done

  if (($#)); then
    case "$1" in
      init) shift; pw::init ;;
      open) shift; pw::open ;;
      lock) shift; pw::lock ;;
      unlock) shift; pw::unlock ;;
      add) shift; pw::add 0 "$@" ;;
      edit) shift; pw::edit "$@" ;;
      rm) shift; pw::rm "$@" ;;
      ls) shift; pw::list ;;
      update) pw::update ;;
      help) pw::help ;;
      *) pw::get ${print} "$@" ;;
    esac
  else
    pw::get ${print}
  fi
}

[[ "${BASH_SOURCE[0]}" != "$0" ]] || main "$@"
