#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

PW_HOME="${BASH_SOURCE[0]}"
while [[ -L "${PW_HOME}" ]]; do
  PW_HOME="$(readlink "${PW_HOME}")"
done
PW_HOME="$(cd "$(dirname "${PW_HOME}")/.." && pwd)"

: "${PW_KEYCHAIN:="pw.keychain"}"

pw::init() {
  security create-keychain -P "${1:-"${PW_KEYCHAIN}"}"
}

pw::add() {
  local name="$1" account="${2:-"${USER}"}" password password2
  read -rsp "Enter password for ${name}: " password
  echo
  read -rsp "Retype password for ${name}: " password2
  echo
  if [[ "${password}" != "${password2}" ]]; then
    echo "Error: the entered passwords do not match."
    exit 1
  fi

  security add-generic-password \
    -a "${account}" \
    -s "${name}" \
    -w "${password}" \
    "${PW_KEYCHAIN}"
}

pw::rm() {
  local name account
  if (($#)); then
    name="$1"
    account="${2:-"${USER}"}"
    security delete-generic-password \
      -a "${account}" \
      -s "${name}" \
      "${PW_KEYCHAIN}"
  else
    while IFS=" " read -r name account; do
      security delete-generic-password \
        -a "${account}" \
        -s "${name}" \
        "${PW_KEYCHAIN}"
    done < <(pw::fzf)
  fi
}

pw::print() {
  local name="$1" account="${2:-"${USER}"}"
  security find-generic-password \
    -a "${account}" \
    -s "${name}" \
    -w \
    "${PW_KEYCHAIN}"
}

pw::copy() {
  pw::print "$@" | pbcopy
}

pw::ls() {
  local dump
  local -a names accounts
  dump="$(security dump-keychain "${PW_KEYCHAIN}")"
  mapfile -t names < <(echo "${dump}" | grep "svce" | awk -F= '{print $2}' | tr -d \")
  mapfile -t accounts < <(echo "${dump}" | grep "acct" | awk -F= '{print $2}' | tr -d \")
  for ((i = 0; i < ${#names[@]}; i++)); do
    echo "${names[i]} | ${accounts[i]}"
  done | column -s '|' -t
}

pw::fzf() {
  pw::ls | fzf --height=1% --layout=reverse --border --info=hidden
}

pw::update() {
  pushd "${PW_HOME}" > /dev/null || exit 1
    git pull origin main
  popd > /dev/null || exit 1
}

pw::help() {
  cat << EOF
usage: pw
  <nothing>                search entry and copy password
  <entry>                  print password for entry
  init [<keychain>]        create keychain (default: pw.keychain)
  add <name> [<account>]   add entry
  rm <name> [<account>]    remove entry
  ls                       list all entries
  update                   update pw
EOF
}

main() {
  if (($#)); then
    case "$1" in
      init) shift; pw::init "$@" ;;
      add) shift; pw::add "$@" ;;
      rm) shift; pw::rm "$@" ;;
      ls) pw::ls ;;
      update) pw::update ;;
      help) pw::help ;;
      *) pw::print "$@" ;;
    esac
  else
    local name account
    while IFS=" " read -r name account; do
      pw::copy "${name}" "${account}"
    done < <(pw::fzf)
  fi
}

main "$@"
